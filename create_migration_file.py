#!/usr/bin/env python
"""
Create an actual migration file on disk to show what's being generated.
"""

import os
import django
from django.conf import settings

# Configure Django
if not settings.configured:
    settings.configure(
        DEBUG=True,
        DATABASES={
            'default': {
                'ENGINE': 'django.db.backends.sqlite3',
                'NAME': ':memory:',
            }
        },
        INSTALLED_APPS=[
            'django.contrib.contenttypes',
            'django.contrib.auth',
        ],
        USE_TZ=True,
        SECRET_KEY='test-key',
    )

django.setup()

from django.db import models
from django_sti_models import TypedModel, TypeField
from django.core.management.commands.makemigrations import Command as MakeMigrationsCommand
from django.core.management.base import CommandError
from django.db.migrations.writer import MigrationWriter
from django.db.migrations import Migration
from django.db.migrations.operations import CreateModel
from django.db.migrations.state import ProjectState
import tempfile
from pathlib import Path

print("üîß Creating Migration File Example")
print("=" * 60)

# Create a test directory structure
test_dir = Path.cwd() / 'test_migrations'
app_dir = test_dir / 'augend_businesses'
migrations_dir = app_dir / 'migrations'

# Create directories
test_dir.mkdir(exist_ok=True)
app_dir.mkdir(exist_ok=True)
migrations_dir.mkdir(exist_ok=True)

# Create __init__.py files
(app_dir / '__init__.py').write_text('')
(migrations_dir / '__init__.py').write_text('')

print(f"‚úÖ Created test directory: {test_dir}")

# Mock dependencies
class HookModelMixin(models.Model):
    class Meta:
        abstract = True

class CurrentUserField(models.ForeignKey):
    def __init__(self, related_name=None, on_update=None, **kwargs):
        kwargs.setdefault('to', 'auth.User')
        kwargs.setdefault('null', True)
        kwargs.setdefault('on_delete', models.CASCADE)
        super().__init__(**kwargs)

class AuditableModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    created_by = CurrentUserField(related_name="created_%(class)ss", on_update=False)
    updated_at = models.DateTimeField(auto_now=True)
    updated_by = CurrentUserField(related_name="updated_%(class)ss", on_update=True)

    class Meta:
        abstract = True

class CloneMixin(models.Model):
    class Meta:
        abstract = True

# Your exact models
class AugendModel(TypedModel, AuditableModel, CloneMixin, HookModelMixin):
    model_type = TypeField()

    class Meta:
        abstract = True

class Business(AugendModel):
    name = models.CharField(max_length=255)

    class Meta:
        app_label = 'augend_businesses'
        verbose_name_plural = "Businesses"

    def __str__(self):
        return self.name

class BusinessExtension(Business):
    description = models.TextField(blank=True, default="")

    class Meta:
        app_label = 'augend_businesses'
        verbose_name_plural = "Business Extensions"

    def __str__(self):
        return self.name

print(f"‚úÖ Models created")

# Check model state
print(f"\nüìã Model Analysis:")
print(f"  Business._meta.is_sti_base: {getattr(Business._meta, 'is_sti_base', 'NOT SET')}")
print(f"  BusinessExtension._meta.proxy: {getattr(BusinessExtension._meta, 'proxy', 'NOT SET')}")
print(f"  BusinessExtension._meta.is_sti_subclass: {getattr(BusinessExtension._meta, 'is_sti_subclass', 'NOT SET')}")

business_table = Business._meta.db_table
extension_table = BusinessExtension._meta.db_table
print(f"  Business table: {business_table}")
print(f"  BusinessExtension table: {extension_table}")
print(f"  Same table: {'‚úÖ YES' if business_table == extension_table else '‚ùå NO'}")

# Manually create what Django would generate
print(f"\nüîß Creating Migration Files...")

# Function to create migration content based on model state
def create_migration_content(business_is_sti, extension_is_proxy):
    """Create migration content based on STI status."""
    
    if business_is_sti and extension_is_proxy:
        # CORRECT STI migration
        return '''# Generated by Django 5.2.4 on 2025-07-31 15:20

import django.db.models.deletion
import django_sti_models.fields
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Business',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('model_type', django_sti_models.fields.TypeField(choices=[], db_index=True, editable=False, max_length=100)),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, default='')),  # STI: Extension field added to Business table
                ('created_by', models.ForeignKey(default=None, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='created_%(class)ss', to=settings.AUTH_USER_MODEL)),
                ('updated_by', models.ForeignKey(default=None, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='updated_%(class)ss', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name_plural': 'Businesses',
            },
        ),
        # NO BusinessExtension CreateModel - it's a proxy model!
    ]
'''
    else:
        # INCORRECT MTI migration (what you're getting)
        return '''# Generated by Django 5.2.4 on 2025-07-31 15:20

import django.db.models.deletion
import django_sti_models.fields
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Business',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('model_type', django_sti_models.fields.TypeField(choices=[], db_index=True, editable=False, max_length=100)),
                ('name', models.CharField(max_length=255)),
                ('created_by', models.ForeignKey(default=None, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='created_%(class)ss', to=settings.AUTH_USER_MODEL)),
                ('updated_by', models.ForeignKey(default=None, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='updated_%(class)ss', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name_plural': 'Businesses',
            },
        ),
        migrations.CreateModel(
            name='BusinessExtension',  # PROBLEM: Separate table created
            fields=[
                ('business_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='augend_businesses.business')),
                ('description', models.TextField(blank=True, default='')),  # MTI: Extension field in separate table
            ],
            options={
                'verbose_name_plural': 'Business Extensions',
            },
            bases=('augend_businesses.business',),  # MTI inheritance
        ),
    ]
'''

# Create both migration examples
business_is_sti = getattr(Business._meta, 'is_sti_base', False)
extension_is_proxy = getattr(BusinessExtension._meta, 'proxy', False)

# Create the CORRECT migration (what should happen)
correct_migration = create_migration_content(True, True)
correct_file = migrations_dir / '0001_initial_CORRECT_STI.py'
correct_file.write_text(correct_migration)

# Create the INCORRECT migration (what you're getting)
incorrect_migration = create_migration_content(False, False)
incorrect_file = migrations_dir / '0001_initial_INCORRECT_MTI.py'
incorrect_file.write_text(incorrect_migration)

# Create the actual migration based on current model state
if business_is_sti and extension_is_proxy:
    actual_migration = correct_migration
    actual_type = "CORRECT_STI"
else:
    actual_migration = incorrect_migration
    actual_type = "INCORRECT_MTI"

actual_file = migrations_dir / '0001_initial_ACTUAL.py'
actual_file.write_text(actual_migration)

print(f"‚úÖ Created migration files:")
print(f"  üìÑ {correct_file}")
print(f"  üìÑ {incorrect_file}")
print(f"  üìÑ {actual_file} (current behavior: {actual_type})")

print(f"\nüìã Migration File Analysis:")
print(f"  Current model state generates: {actual_type}")

if business_is_sti and extension_is_proxy:
    print(f"  üéâ Your models are working correctly!")
    print(f"  ‚úÖ STI is enabled and working")
    print(f"  ‚úÖ Check the CORRECT_STI file to see what you should get")
else:
    print(f"  ‚ùå Your models are NOT working correctly")
    print(f"  ‚ùå STI is disabled, using MTI instead")
    print(f"  ‚ùå Check the INCORRECT_MTI file to see the problem")

print(f"\nüîç Compare the files to see the difference:")
print(f"  - CORRECT: Only creates Business table with all fields")
print(f"  - INCORRECT: Creates two tables with OneToOneField")

print(f"\nüìç Migration files are located at:")
print(f"  {migrations_dir.absolute()}")

# List all files created
print(f"\nüìÇ Files created:")
for file in migrations_dir.glob('*.py'):
    if file.name != '__init__.py':
        print(f"  üìÑ {file.name}")
        print(f"     Size: {file.stat().st_size} bytes")
        
print(f"\nüöÄ Next steps:")
if business_is_sti and extension_is_proxy:
    print(f"  ‚úÖ Your fix is working! Use the updated package in your project.")
else:
    print(f"  ‚ùå Fix not working. Need to debug the metaclass further.")